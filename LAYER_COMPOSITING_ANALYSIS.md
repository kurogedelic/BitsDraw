# BitsDraw レイヤー合成システム 詳細分析レポート

## 現在の実装状況

### 1. 現在の合成アルゴリズム

#### 実装場所
- **メインファイル**: `/utils/optimizedBitmap.js`
- **関数**: `compositeAllLayers()` (行 942-984)
- **実行タイミング**: `renderFull()` と `renderPartial()` から呼び出し

#### 現在の合成プロセス
```javascript
compositeAllLayers() {
    // キャッシュチェック
    if (!this.compositeCacheDirty && this.compositeCache) {
        return this.compositeCache; // キャッシュヒット
    }
    
    // 全体合成処理
    this.compositeCache.pixels.fill(0);
    this.compositeCache.alpha.fill(0);
    
    // 全レイヤーを下から上へ合成
    for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        if (!layer.visible) continue;
        
        // 全ピクセルを処理
        for (let j = 0; j < this.compositeCache.pixels.length; j++) {
            // 単純な上書き合成
        }
    }
}
```

#### 合成ロジック
- **ブレンドモード**: 上位レイヤー優先の単純上書き
- **アルファ処理**: 1-bit アルファ (0=透明, 1=不透明)
- **処理単位**: 全キャンバス (width × height ピクセル)

### 2. パフォーマンス問題の特定

#### 現在のボトルネック

1. **全体合成の頻発**
   - 任意のレイヤー変更で全キャンバス再合成
   - 128×64 キャンバスで 8,192 ピクセル処理
   - 5レイヤーで 40,960 オペレーション

2. **部分更新の未活用**
   - Dirty Rectangle システムは描画処理のみで使用
   - レイヤー合成では全領域処理
   - 1ピクセル変更でも全体合成

3. **レイヤー別キャッシュの不在**
   - 個別レイヤーのキャッシュなし
   - 1レイヤー変更で全レイヤー再処理
   - レイヤー可視性変更でも全体再合成

#### パフォーマンス測定結果（推定）

| レイヤー数 | キャンバスサイズ | 合成時間（ms） | FPS影響 |
|-----------|----------------|---------------|---------|
| 3         | 128×64         | 2-3           | 軽微    |
| 5         | 128×64         | 4-6           | 中程度  |
| 8         | 256×128        | 15-25         | 重大    |
| 10        | 512×256        | 60-100        | 重大    |

### 3. キャッシングシステムの分析

#### 現在のキャッシュ構造
```javascript
this.compositeCache = {
    pixels: new Uint8Array(width * height),
    alpha: new Uint8Array(width * height)
};
this.compositeCacheDirty = true;
```

#### 無効化タイミング
- `markCompositeDirty()` 呼び出し時
- レイヤー追加・削除・変更
- レイヤー可視性変更
- ピクセル描画操作

#### キャッシュの問題点
1. **粗い粒度**: 全体キャッシュのみ
2. **頻繁な無効化**: 小さな変更でも全無効化
3. **メモリ効率**: 中間キャッシュデータなし

### 4. Dirty Rectangle システムとの連携状況

#### 現在の連携度
- **描画処理**: 効果的に活用
- **合成処理**: 未活用（全体処理）
- **レンダリング**: 部分描画対応済み

#### 連携の機会
- 合成処理での部分更新
- レイヤー別 dirty rectangle 管理
- インクリメンタル合成の実装

## 最適化実装案

### 1. インクリメンタル合成システム

#### 概要
変更された領域のみを合成する部分更新システム

#### 実装方針
```javascript
// レイヤー別 dirty rectangle 管理
this.layerDirtyRects = new Map();

// 部分合成処理
compositeRectangle(dirtyRect) {
    // 指定領域のみを合成
    for (let layer of visibleLayers) {
        this.compositeLayerRectangle(layer, dirtyRect);
    }
}
```

#### 期待効果
- **処理時間**: 60-80% 削減（小さな変更時）
- **メモリ使用量**: 変更なし
- **実装複雑度**: 中程度

### 2. レイヤー別キャッシングシステム

#### 概要
各レイヤーの描画結果を個別にキャッシュ

#### データ構造
```javascript
this.layerCaches = new Map(); // レイヤーID → キャッシュデータ
layerCache = {
    pixels: Uint8Array,
    alpha: Uint8Array, 
    rendered: ImageData, // 事前描画データ
    dirty: boolean,
    lastUpdate: timestamp
};
```

#### 期待効果
- **処理時間**: 40-60% 削減（部分レイヤー変更時）
- **メモリ使用量**: 2-3倍増加
- **キャッシュヒット率**: 70-85%

### 3. バックグラウンド合成処理

#### 概要
Web Worker を使用した非同期合成

#### 適用条件
- キャンバスサイズ > 256×256
- レイヤー数 > 5
- 複雑なブレンドモード使用時

#### 実装アーキテクチャ
```javascript
// メインスレッド
const worker = new Worker('compositor-worker.js');
worker.postMessage({
    layers: serializeLayers(),
    dirtyRects: getDirtyRects()
});

// Worker スレッド
self.onmessage = function(e) {
    const result = performCompositing(e.data);
    self.postMessage(result);
};
```

#### 期待効果
- **UI応答性**: 大幅改善
- **処理時間**: 変更なし
- **実装複雑度**: 高

### 4. GPU アクセラレーション

#### 概要
WebGL シェーダーを使用した並列処理

#### 実装範囲
- 基本ブレンド演算
- アルファ合成
- 大規模キャンバス処理

#### 制約事項
- WebGL 対応ブラウザ必須
- メモリ転送コスト
- デバッグ困難

## 実装優先度と段階的導入

### Phase 1: インクリメンタル合成（高優先度）
- **実装時間**: 2-3日
- **リスク**: 低
- **効果**: 高
- **後方互換性**: 完全

#### 実装ステップ
1. レイヤー別 dirty rectangle 管理
2. 部分合成メソッド実装
3. 既存システムとの統合
4. パフォーマンステスト

### Phase 2: レイヤーキャッシングシステム（中優先度）  
- **実装時間**: 3-4日
- **リスク**: 中
- **効果**: 高
- **メモリ要件**: 増加

#### 実装ステップ
1. キャッシュデータ構造設計
2. キャッシュ管理システム
3. メモリ制限対応
4. 無効化ロジック改善

### Phase 3: バックグラウンド処理（低優先度）
- **実装時間**: 5-7日  
- **リスク**: 高
- **効果**: 中（大規模時）
- **複雑度**: 高

#### 実装ステップ
1. Worker スレッド設計
2. データシリアライゼーション
3. 非同期通信実装
4. エラーハンドリング

## 互換性とリスク評価

### 後方互換性
- **既存API**: 完全保持
- **データ形式**: 変更なし
- **動作**: 透過的な最適化

### 実装リスク
1. **メモリ使用量増加**: レイヤーキャッシュ導入時
2. **デバグ困難**: 非同期処理導入時
3. **ブラウザ互換性**: GPU アクセラレーション時

### 回避策
- プログレッシブ実装（段階的導入）
- フォールバック機能
- 設定による無効化オプション

## テストとベンチマーク

### パフォーマンステスト
```javascript
// テストケース
const testScenarios = [
    { layers: 3, size: '128×64', operations: 100 },
    { layers: 5, size: '256×128', operations: 200 },
    { layers: 8, size: '512×256', operations: 500 }
];

// 測定項目
- 平均合成時間
- メモリ使用量
- キャッシュヒット率
- UI応答性（FPS）
```

### 品質保証
- 全描画ツールでの動作確認
- レイヤー操作の正確性検証
- エクスポート結果の一致確認
- メモリリーク検証

## 結論と推奨事項

### 即座に実装すべき最適化
1. **インクリメンタル合成**: 最大の効果、最小のリスク
2. **キャッシュ無効化ロジック改善**: 現在システムの大幅改善

### 中期的な実装目標
1. **レイヤー別キャッシング**: メモリ管理と合わせて実装
2. **パフォーマンス監視**: 実運用データの収集

### 長期的な検討項目
1. **GPU アクセラレーション**: ハイエンド機能として
2. **Web Worker**: 大規模処理対応として

### 実装の開始手順
1. 性能測定ツール（`layer_performance_analysis.js`）の統合
2. Phase 1 の実装着手
3. 継続的なパフォーマンス監視体制構築

現在の実装は基本的な機能は良好だが、多レイヤー環境でのスケーラビリティに課題がある。段階的な最適化により、ユーザー体験を大幅に改善できる見込み。