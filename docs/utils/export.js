class U8G2Exporter {
    static generateHFile(bitmapData, projectName = 'my_bitmap') {
        const { width, height, pixels } = bitmapData;
        const bytes = this.pixelsToBytes(pixels, width, height);
        
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw - U8G2 Bitmap Editor\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// u8g2.drawXBM(x, y, ${width}, ${height}, ${projectName});`;
        
        return code;
    }

    static pixelsToBytes(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << bit);
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    static copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            return navigator.clipboard.writeText(text);
        } else {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            return new Promise((resolve, reject) => {
                try {
                    document.execCommand('copy');
                    textArea.remove();
                    resolve();
                } catch (err) {
                    textArea.remove();
                    reject(err);
                }
            });
        }
    }

    static parseDimensions(code) {
        const widthMatch = code.match(/\/\/\s*Size:\s*(\d+)\s*x\s*(\d+)/);
        if (widthMatch) {
            return {
                width: parseInt(widthMatch[1]),
                height: parseInt(widthMatch[2])
            };
        }
        
        const drawXBMMatch = code.match(/drawXBM\([^,]+,\s*[^,]+,\s*(\d+),\s*(\d+)/);
        if (drawXBMMatch) {
            return {
                width: parseInt(drawXBMMatch[1]),
                height: parseInt(drawXBMMatch[2])
            };
        }
        
        return null;
    }

    static parseHFile(code) {
        try {
            const dimensions = this.parseDimensions(code);
            if (!dimensions) {
                throw new Error('Could not parse bitmap dimensions from code');
            }
            
            const { width, height } = dimensions;
            
            const arrayMatch = code.match(/{\s*((?:0x[0-9a-fA-F]{2}(?:,\s*)?)+)\s*}/);
            if (!arrayMatch) {
                throw new Error('Could not parse byte array from code');
            }
            
            const hexValues = arrayMatch[1].match(/0x[0-9a-fA-F]{2}/g);
            if (!hexValues) {
                throw new Error('No valid hex values found');
            }
            
            const bytes = hexValues.map(hex => parseInt(hex, 16));
            const pixels = this.bytesToPixels(bytes, width, height);
            
            return {
                width,
                height,
                pixels
            };
        } catch (error) {
            console.error('Error parsing H file:', error);
            throw error;
        }
    }

    static bytesToPixels(bytes, width, height) {
        const pixels = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            pixels[y] = new Array(width).fill(0);
            
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                const bytePos = y * bytesPerRow + byteIndex;
                if (bytePos < bytes.length) {
                    const byte = bytes[bytePos];
                    
                    for (let bit = 0; bit < 8; bit++) {
                        const x = byteIndex * 8 + bit;
                        if (x < width) {
                            pixels[y][x] = (byte & (1 << bit)) ? 1 : 0;
                        }
                    }
                }
            }
        }
        
        return pixels;
    }
}