class BitmapExporter {
    static generateHFile(bitmapData, projectName = 'my_bitmap', format = 'u8g2') {
        const { width, height, pixels } = bitmapData;
        
        let bytes, code;
        
        switch (format) {
            case 'adafruit':
                bytes = this.pixelsToBytesAdafruit(pixels, width, height);
                code = this.generateAdafruitCode(bytes, width, height, projectName);
                break;
            case 'gameboy':
                return this.generateGameBoy2BPP(pixels, width, height, projectName);
            default: // u8g2
                bytes = this.pixelsToBytesU8G2(pixels, width, height);
                code = this.generateU8G2Code(bytes, width, height, projectName);
                break;
        }
        
        return code;
    }

    static generateU8G2Code(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - U8G2 Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: XBM (LSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// u8g2.drawXBM(x, y, ${width}, ${height}, ${projectName});`;
        
        return code;
    }

    static generateAdafruitCode(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - Adafruit Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: Adafruit GFX (MSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// display.drawBitmap(x, y, ${projectName}, ${width}, ${height}, color);`;
        
        return code;
    }

    static pixelsToBytesU8G2(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // U8G2 uses LSB first (XBM format)
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << bit);
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    static pixelsToBytesAdafruit(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // Adafruit uses MSB first
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << (7 - bit)); // MSB first
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    // Playdate PDI export removed
    
    // Game Boy 2BPP format implementation
    static generateGameBoy2BPP(pixels, width, height, projectName) {
        // Game Boy uses 8x8 tiles
        const tilesX = Math.ceil(width / 8);
        const tilesY = Math.ceil(height / 8);
        const tiles = [];
        
        // Process each 8x8 tile
        for (let tileY = 0; tileY < tilesY; tileY++) {
            for (let tileX = 0; tileX < tilesX; tileX++) {
                const tile = [];
                
                // Each tile is 16 bytes (8 rows Ã— 2 bytes per row)
                for (let row = 0; row < 8; row++) {
                    let lowByte = 0;
                    let highByte = 0;
                    
                    for (let col = 0; col < 8; col++) {
                        const x = tileX * 8 + col;
                        const y = tileY * 8 + row;
                        
                        // Get pixel value (default to 0 if outside bounds)
                        let pixelValue = 0;
                        if (x < width && y < height) {
                            // Convert 1-bit to 2-bit
                            // BitsDraw: 1 = black, 0 = white
                            // Game Boy: 0 = white, 3 = black
                            pixelValue = pixels[y][x] ? 3 : 0;
                        }
                        
                        // Extract low and high bits
                        const lowBit = pixelValue & 1;
                        const highBit = (pixelValue >> 1) & 1;
                        
                        // Pack bits (MSB first)
                        lowByte |= (lowBit << (7 - col));
                        highByte |= (highBit << (7 - col));
                    }
                    
                    // Game Boy format: low byte first, then high byte
                    tile.push(lowByte);
                    tile.push(highByte);
                }
                
                tiles.push(...tile);
            }
        }
        
        const hexValues = tiles.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - Game Boy 2BPP Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Tiles: ${tilesX} x ${tilesY} (${tilesX * tilesY} tiles)\n`;
        code += `// Data size: ${tiles.length} bytes\n`;
        code += `// Format: Game Boy 2BPP (16 bytes per 8x8 tile)\n\n`;
        code += `const unsigned char ${projectName}_tiles[] = {\n`;
        
        // Format output with comments for each tile
        let tileIndex = 0;
        for (let i = 0; i < hexValues.length; i += 16) {
            code += `    // Tile ${tileIndex}\n`;
            const tileBytes = hexValues.slice(i, i + 16);
            
            // Output 8 rows (2 bytes each)
            for (let row = 0; row < 8; row++) {
                const rowBytes = tileBytes.slice(row * 2, row * 2 + 2);
                code += `    ${rowBytes.join(', ')}`;
                if (row < 7 || i + 16 < hexValues.length) {
                    code += ',';
                }
                code += `  // Row ${row}\n`;
            }
            
            if (i + 16 < hexValues.length) {
                code += '\n';
            }
            tileIndex++;
        }
        
        code += `};\n\n`;
        code += `// GBDK usage example:\n`;
        code += `// set_bkg_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        code += `// For sprites: set_sprite_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        
        return code;
    }

    // ========================================
    // Modern Export Formats
    // ========================================

    /**
     * Get available export formats
     */
    static getExportFormats() {
        return {
            // Hardware formats
            'u8g2': { name: 'U8G2', description: 'Arduino U8G2 Library Format', category: 'hardware' },
            'adafruit': { name: 'Adafruit GFX', description: 'Adafruit GFX Library Format', category: 'hardware' },
            'gameboy': { name: 'Game Boy 2BPP', description: 'Game Boy Tile Format', category: 'hardware' },
            
            // Image formats
            'png': { name: 'PNG', description: 'Portable Network Graphics', category: 'image' }
        };
    }

    // SVG export methods removed

    /**
     * Export to Base64 Data URL
     */
    static generateBase64(bitmapData, format = 'png', options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            scale = 1,
            fillColor = '#000000',
            backgroundColor = '#FFFFFF'
        } = options;

        return new Promise((resolve, reject) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = width * scale;
            canvas.height = height * scale;

            // Fill background
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pixels
            ctx.fillStyle = fillColor;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (pixels[y][x]) {
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            try {
                // Only PNG format supported
                const dataURL = canvas.toDataURL('image/png', 0.9);
                resolve(dataURL);
            } catch (error) {
                reject(error);
            }
        });
    }

    // JSON export methods removed

    // ASCII Art export removed

    // CSS export method removed

    // Raw Binary export removed

    /**
     * Unified export method for all formats
     */
    static async exportBitmap(bitmapData, format = 'u8g2', projectName = 'bitmap', options = {}) {
        const { width, height, pixels } = bitmapData;

        switch (format) {
            case 'u8g2':
                return this.generateHFile(bitmapData, projectName, 'u8g2');
            case 'adafruit':
                return this.generateHFile(bitmapData, projectName, 'adafruit');
            case 'gameboy':
                return this.generateHFile(bitmapData, projectName, 'gameboy');
            case 'png':
                return await this.generateBase64(bitmapData, format, options);
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }

    /**
     * Download exported data as file
     */
    static downloadExport(data, filename, format) {
        const mimeTypes = {
            'u8g2': 'text/plain',
            'adafruit': 'text/plain',
            'gameboy': 'text/plain'
        };

        const fileExtensions = {
            'u8g2': '.h',
            'adafruit': '.h',
            'gameboy': '.h',
            'png': '.png'
        };

        let blob;
        const mimeType = mimeTypes[format] || 'text/plain';
        const extension = fileExtensions[format] || '.txt';

        if (format === 'raw') {
            blob = new Blob([data], { type: mimeType });
        } else if (format === 'base64' || format === 'png' || format === 'webp') {
            // For base64 data URLs, extract the base64 part and convert to blob
            if (typeof data === 'string' && data.startsWith('data:')) {
                const base64Data = data.split(',')[1];
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                blob = new Blob([bytes], { type: data.split(';')[0].split(':')[1] });
            } else {
                blob = new Blob([data], { type: mimeType });
            }
        } else {
            blob = new Blob([data], { type: mimeType });
        }

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename + extension;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    /**
     * Get file size estimate for export format
     */
    static getExportSizeEstimate(bitmapData, format) {
        const { width, height } = bitmapData;
        const pixelCount = width * height;

        switch (format) {
            case 'u8g2':
            case 'adafruit':
                return Math.ceil(pixelCount / 8) * 5; // Hex representation overhead
            // Playdate format removed
            case 'gameboy':
                return Math.ceil(width / 8) * height * 16 * 5; // 16 bytes per tile
            case 'svg':
                return width * height * 20; // Estimate for path data
            case 'json':
                return pixelCount * 2; // Array representation
            // ASCII and Raw Binary export formats removed
            case 'png':
            case 'webp':
                return pixelCount * 4; // Rough estimate for image data
            default:
                return pixelCount;
        }
    }

    // Legacy method for backward compatibility
    static pixelsToBytes(pixels, width, height) {
        return this.pixelsToBytesU8G2(pixels, width, height);
    }

    static copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            return navigator.clipboard.writeText(text);
        } else {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            return new Promise((resolve, reject) => {
                try {
                    document.execCommand('copy');
                    textArea.remove();
                    resolve();
                } catch (err) {
                    textArea.remove();
                    reject(err);
                }
            });
        }
    }

    static parseDimensions(code) {
        const widthMatch = code.match(/\/\/\s*Size:\s*(\d+)\s*x\s*(\d+)/);
        if (widthMatch) {
            return {
                width: parseInt(widthMatch[1]),
                height: parseInt(widthMatch[2])
            };
        }
        
        const drawXBMMatch = code.match(/drawXBM\([^,]+,\s*[^,]+,\s*(\d+),\s*(\d+)/);
        if (drawXBMMatch) {
            return {
                width: parseInt(drawXBMMatch[1]),
                height: parseInt(drawXBMMatch[2])
            };
        }
        
        return null;
    }

    static parseHFile(code) {
        try {
            const dimensions = this.parseDimensions(code);
            if (!dimensions) {
                throw new Error('Could not parse bitmap dimensions from code');
            }
            
            const { width, height } = dimensions;
            
            const arrayMatch = code.match(/{\s*((?:0x[0-9a-fA-F]{2}(?:,\s*)?)+)\s*}/);
            if (!arrayMatch) {
                throw new Error('Could not parse byte array from code');
            }
            
            const hexValues = arrayMatch[1].match(/0x[0-9a-fA-F]{2}/g);
            if (!hexValues) {
                throw new Error('No valid hex values found');
            }
            
            const bytes = hexValues.map(hex => parseInt(hex, 16));
            const pixels = this.bytesToPixels(bytes, width, height);
            
            return {
                width,
                height,
                pixels
            };
        } catch (error) {
            console.error('Error parsing H file:', error);
            throw error;
        }
    }

    static bytesToPixels(bytes, width, height) {
        const pixels = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            pixels[y] = new Array(width).fill(0);
            
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                const bytePos = y * bytesPerRow + byteIndex;
                if (bytePos < bytes.length) {
                    const byte = bytes[bytePos];
                    
                    for (let bit = 0; bit < 8; bit++) {
                        const x = byteIndex * 8 + bit;
                        if (x < width) {
                            pixels[y][x] = (byte & (1 << bit)) ? 1 : 0;
                        }
                    }
                }
            }
        }
        
        return pixels;
    }
}

// Backward compatibility alias
const U8G2Exporter = BitmapExporter;