class BitmapExporter {
    static generateHFile(bitmapData, projectName = 'my_bitmap', format = 'u8g2') {
        const { width, height, pixels } = bitmapData;
        
        let bytes, code;
        
        switch (format) {
            case 'adafruit':
                bytes = this.pixelsToBytesAdafruit(pixels, width, height);
                code = this.generateAdafruitCode(bytes, width, height, projectName);
                break;
            case 'playdate':
                return this.generatePlaydatePDI(pixels, width, height, projectName);
            case 'gameboy':
                return this.generateGameBoy2BPP(pixels, width, height, projectName);
            default: // u8g2
                bytes = this.pixelsToBytesU8G2(pixels, width, height);
                code = this.generateU8G2Code(bytes, width, height, projectName);
                break;
        }
        
        return code;
    }

    static generateU8G2Code(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - U8G2 Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: XBM (LSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// u8g2.drawXBM(x, y, ${width}, ${height}, ${projectName});`;
        
        return code;
    }

    static generateAdafruitCode(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - Adafruit Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: Adafruit GFX (MSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// display.drawBitmap(x, y, ${projectName}, ${width}, ${height}, color);`;
        
        return code;
    }

    static pixelsToBytesU8G2(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // U8G2 uses LSB first (XBM format)
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << bit);
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    static pixelsToBytesAdafruit(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // Adafruit uses MSB first
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << (7 - bit)); // MSB first
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    // Playdate PDI format implementation
    static generatePlaydatePDI(pixels, width, height, projectName) {
        // Create byte array for PDI format
        const stride = Math.ceil(width / 8);
        const bytes = [];
        
        // Convert pixels to Playdate format (0 = black, 1 = white)
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < stride; byteIndex++) {
                let byte = 0;
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        // In BitsDraw: 1 = black, 0 = white
                        // In Playdate: 0 = black, 1 = white
                        // So we need to invert
                        const pixelValue = pixels[y][x] ? 0 : 1;
                        if (pixelValue) {
                            byte |= (1 << (7 - bit)); // MSB first for Playdate
                        }
                    }
                }
                bytes.push(byte);
            }
        }
        
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - Playdate PDI Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: Playdate PDI (0=black, 1=white, MSB first)\n`;
        code += `// Note: This is raw bitmap data. For actual PDI file, add header.\n\n`;
        code += `static const uint8_t ${projectName}_bitmap[] = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `    ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Playdate C API usage:\n`;
        code += `// LCDBitmap* bitmap = pd->graphics->newBitmap(${width}, ${height}, kColorWhite);\n`;
        code += `// pd->graphics->getBitmapData(bitmap, NULL, NULL, &rowbytes, NULL, &data);\n`;
        code += `// memcpy(data, ${projectName}_bitmap, sizeof(${projectName}_bitmap));\n`;
        
        return code;
    }
    
    // Game Boy 2BPP format implementation
    static generateGameBoy2BPP(pixels, width, height, projectName) {
        // Game Boy uses 8x8 tiles
        const tilesX = Math.ceil(width / 8);
        const tilesY = Math.ceil(height / 8);
        const tiles = [];
        
        // Process each 8x8 tile
        for (let tileY = 0; tileY < tilesY; tileY++) {
            for (let tileX = 0; tileX < tilesX; tileX++) {
                const tile = [];
                
                // Each tile is 16 bytes (8 rows × 2 bytes per row)
                for (let row = 0; row < 8; row++) {
                    let lowByte = 0;
                    let highByte = 0;
                    
                    for (let col = 0; col < 8; col++) {
                        const x = tileX * 8 + col;
                        const y = tileY * 8 + row;
                        
                        // Get pixel value (default to 0 if outside bounds)
                        let pixelValue = 0;
                        if (x < width && y < height) {
                            // Convert 1-bit to 2-bit
                            // BitsDraw: 1 = black, 0 = white
                            // Game Boy: 0 = white, 3 = black
                            pixelValue = pixels[y][x] ? 3 : 0;
                        }
                        
                        // Extract low and high bits
                        const lowBit = pixelValue & 1;
                        const highBit = (pixelValue >> 1) & 1;
                        
                        // Pack bits (MSB first)
                        lowByte |= (lowBit << (7 - col));
                        highByte |= (highBit << (7 - col));
                    }
                    
                    // Game Boy format: low byte first, then high byte
                    tile.push(lowByte);
                    tile.push(highByte);
                }
                
                tiles.push(...tile);
            }
        }
        
        const hexValues = tiles.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.4 - Game Boy 2BPP Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Tiles: ${tilesX} x ${tilesY} (${tilesX * tilesY} tiles)\n`;
        code += `// Data size: ${tiles.length} bytes\n`;
        code += `// Format: Game Boy 2BPP (16 bytes per 8x8 tile)\n\n`;
        code += `const unsigned char ${projectName}_tiles[] = {\n`;
        
        // Format output with comments for each tile
        let tileIndex = 0;
        for (let i = 0; i < hexValues.length; i += 16) {
            code += `    // Tile ${tileIndex}\n`;
            const tileBytes = hexValues.slice(i, i + 16);
            
            // Output 8 rows (2 bytes each)
            for (let row = 0; row < 8; row++) {
                const rowBytes = tileBytes.slice(row * 2, row * 2 + 2);
                code += `    ${rowBytes.join(', ')}`;
                if (row < 7 || i + 16 < hexValues.length) {
                    code += ',';
                }
                code += `  // Row ${row}\n`;
            }
            
            if (i + 16 < hexValues.length) {
                code += '\n';
            }
            tileIndex++;
        }
        
        code += `};\n\n`;
        code += `// GBDK usage example:\n`;
        code += `// set_bkg_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        code += `// For sprites: set_sprite_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        
        return code;
    }

    // ========================================
    // Modern Export Formats
    // ========================================

    /**
     * Get available export formats
     */
    static getExportFormats() {
        return {
            // Hardware formats
            'u8g2': { name: 'U8G2', description: 'Arduino U8G2 Library Format', category: 'hardware' },
            'adafruit': { name: 'Adafruit GFX', description: 'Adafruit GFX Library Format', category: 'hardware' },
            'playdate': { name: 'Playdate PDI', description: 'Playdate Console Format', category: 'hardware' },
            'gameboy': { name: 'Game Boy 2BPP', description: 'Game Boy Tile Format', category: 'hardware' },
            
            // Modern formats
            'svg': { name: 'SVG', description: 'Scalable Vector Graphics', category: 'vector' },
            'base64': { name: 'Base64', description: 'Base64 Data URL', category: 'data' },
            'json': { name: 'JSON', description: 'JSON Array Format', category: 'data' },
            'raw': { name: 'Raw Binary', description: 'Raw Binary Data', category: 'data' },
            
            // Image formats
            'png': { name: 'PNG', description: 'Portable Network Graphics', category: 'image' },
            'webp': { name: 'WebP', description: 'Modern WebP Format', category: 'image' },
            
            // Text formats
            'ascii': { name: 'ASCII Art', description: 'Text-based ASCII Art', category: 'text' },
            'css': { name: 'CSS', description: 'CSS Background Image', category: 'web' }
        };
    }

    /**
     * Export to SVG format
     */
    static generateSVG(bitmapData, projectName = 'bitmap', options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            pixelSize = 1,
            fillColor = '#000000',
            backgroundColor = '#FFFFFF',
            optimize = true
        } = options;

        const svgWidth = width * pixelSize;
        const svgHeight = height * pixelSize;

        let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        svg += `<svg xmlns="http://www.w3.org/2000/svg" `;
        svg += `width="${svgWidth}" height="${svgHeight}" `;
        svg += `viewBox="0 0 ${svgWidth} ${svgHeight}">\n`;
        svg += `  <title>${projectName}</title>\n`;
        svg += `  <desc>Generated by BitsDraw v1.0.4 - SVG Export</desc>\n`;

        // Background
        if (backgroundColor && backgroundColor !== 'transparent') {
            svg += `  <rect width="${svgWidth}" height="${svgHeight}" fill="${backgroundColor}"/>\n`;
        }

        if (optimize) {
            // Optimized path-based approach
            svg += `  <path d="`;
            const paths = this.generateSVGPaths(pixels, width, height, pixelSize);
            svg += paths.join(' ');
            svg += `" fill="${fillColor}"/>\n`;
        } else {
            // Individual rectangles (larger file size but more compatible)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (pixels[y][x]) {
                        const rectX = x * pixelSize;
                        const rectY = y * pixelSize;
                        svg += `  <rect x="${rectX}" y="${rectY}" width="${pixelSize}" height="${pixelSize}" fill="${fillColor}"/>\n`;
                    }
                }
            }
        }

        svg += `</svg>`;
        return svg;
    }

    /**
     * Generate optimized SVG paths for pixel data
     */
    static generateSVGPaths(pixels, width, height, pixelSize) {
        const paths = [];
        const visited = Array(height).fill().map(() => Array(width).fill(false));

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (pixels[y][x] && !visited[y][x]) {
                    // Find rectangular region starting from this pixel
                    const rect = this.findRectangularRegion(pixels, visited, x, y, width, height);
                    if (rect.width > 0 && rect.height > 0) {
                        const pathX = rect.x * pixelSize;
                        const pathY = rect.y * pixelSize;
                        const pathWidth = rect.width * pixelSize;
                        const pathHeight = rect.height * pixelSize;
                        paths.push(`M${pathX},${pathY}h${pathWidth}v${pathHeight}h-${pathWidth}z`);
                    }
                }
            }
        }

        return paths;
    }

    /**
     * Find rectangular region of filled pixels
     */
    static findRectangularRegion(pixels, visited, startX, startY, width, height) {
        let rectWidth = 0;
        let rectHeight = 1;

        // Find maximum width for the first row
        for (let x = startX; x < width && pixels[startY][x] && !visited[startY][x]; x++) {
            rectWidth++;
        }

        // Check subsequent rows to see if we can extend the rectangle
        for (let y = startY + 1; y < height; y++) {
            let canExtend = true;
            for (let x = startX; x < startX + rectWidth; x++) {
                if (!pixels[y][x] || visited[y][x]) {
                    canExtend = false;
                    break;
                }
            }
            if (canExtend) {
                rectHeight++;
            } else {
                break;
            }
        }

        // Mark all pixels in the rectangle as visited
        for (let y = startY; y < startY + rectHeight; y++) {
            for (let x = startX; x < startX + rectWidth; x++) {
                visited[y][x] = true;
            }
        }

        return {
            x: startX,
            y: startY,
            width: rectWidth,
            height: rectHeight
        };
    }

    /**
     * Export to Base64 Data URL
     */
    static generateBase64(bitmapData, format = 'png', options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            scale = 1,
            fillColor = '#000000',
            backgroundColor = '#FFFFFF'
        } = options;

        return new Promise((resolve, reject) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = width * scale;
            canvas.height = height * scale;

            // Fill background
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pixels
            ctx.fillStyle = fillColor;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (pixels[y][x]) {
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            try {
                const mimeType = format === 'webp' ? 'image/webp' : 'image/png';
                const dataURL = canvas.toDataURL(mimeType, 0.9);
                resolve(dataURL);
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Export to JSON format
     */
    static generateJSON(bitmapData, projectName = 'bitmap', options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            format = 'array', // 'array', 'object', 'compressed'
            includeMetadata = true
        } = options;

        const result = {};

        if (includeMetadata) {
            result.meta = {
                name: projectName,
                width: width,
                height: height,
                format: 'BitsDraw JSON Export',
                version: '1.0.4',
                exported: new Date().toISOString()
            };
        }

        switch (format) {
            case 'array':
                result.pixels = pixels;
                break;
            case 'flat':
                result.pixels = pixels.flat();
                break;
            case 'compressed':
                result.pixels = this.compressPixelData(pixels, width, height);
                break;
            case 'rle':
                result.pixels = this.runLengthEncode(pixels.flat());
                break;
            default:
                result.pixels = pixels;
        }

        return JSON.stringify(result, null, 2);
    }

    /**
     * Compress pixel data using simple RLE
     */
    static runLengthEncode(flatPixels) {
        const compressed = [];
        let current = flatPixels[0];
        let count = 1;

        for (let i = 1; i < flatPixels.length; i++) {
            if (flatPixels[i] === current) {
                count++;
            } else {
                compressed.push([current, count]);
                current = flatPixels[i];
                count = 1;
            }
        }
        compressed.push([current, count]);

        return compressed;
    }

    /**
     * Export to ASCII Art
     */
    static generateASCII(bitmapData, projectName = 'bitmap', options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            charSet = '██', // Characters for filled pixels
            emptyChar = '  ', // Characters for empty pixels
            lineNumbers = false,
            border = false
        } = options;

        let ascii = `// ASCII Art Export - ${projectName}\n`;
        ascii += `// Size: ${width}×${height} pixels\n`;
        ascii += `// Generated by BitsDraw v1.0.4\n\n`;

        if (border) {
            const borderLine = '═'.repeat(width * charSet.length + 4);
            ascii += `╔${borderLine}╗\n`;
        }

        for (let y = 0; y < height; y++) {
            let line = '';
            
            if (border) line += '║ ';
            if (lineNumbers) line += `${y.toString().padStart(3, '0')}: `;

            for (let x = 0; x < width; x++) {
                line += pixels[y][x] ? charSet : emptyChar;
            }

            if (border) line += ' ║';
            ascii += line + '\n';
        }

        if (border) {
            const borderLine = '═'.repeat(width * charSet.length + 4);
            ascii += `╚${borderLine}╝\n`;
        }

        return ascii;
    }

    /**
     * Export to CSS format
     */
    static async generateCSS(bitmapData, projectName = 'bitmap', options = {}) {
        const { width, height } = bitmapData;
        const {
            format = 'dataurl', // 'dataurl', 'base64'
            className = projectName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
            pixelSize = '1px'
        } = options;

        let css = `/* CSS Export - ${projectName} */\n`;
        css += `/* Size: ${width}×${height} pixels */\n`;
        css += `/* Generated by BitsDraw v1.0.4 */\n\n`;

        if (format === 'dataurl') {
            const dataURL = await this.generateBase64(bitmapData, 'png', options);
            css += `.${className} {\n`;
            css += `  width: ${width * parseInt(pixelSize)}px;\n`;
            css += `  height: ${height * parseInt(pixelSize)}px;\n`;
            css += `  background-image: url("${dataURL}");\n`;
            css += `  background-size: cover;\n`;
            css += `  background-repeat: no-repeat;\n`;
            css += `}\n`;
        }

        return css;
    }

    /**
     * Export to Raw Binary format
     */
    static generateRawBinary(bitmapData, options = {}) {
        const { width, height, pixels } = bitmapData;
        const {
            format = 'uint8', // 'uint8', 'bits'
            packed = true
        } = options;

        if (format === 'bits' && packed) {
            // Pack 8 pixels per byte
            const bytesPerRow = Math.ceil(width / 8);
            const totalBytes = bytesPerRow * height;
            const buffer = new Uint8Array(totalBytes);

            for (let y = 0; y < height; y++) {
                for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                    let byte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const x = byteIndex * 8 + bit;
                        if (x < width && pixels[y][x]) {
                            byte |= (1 << (7 - bit)); // MSB first
                        }
                    }
                    buffer[y * bytesPerRow + byteIndex] = byte;
                }
            }

            return buffer;
        } else {
            // One byte per pixel
            const buffer = new Uint8Array(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    buffer[y * width + x] = pixels[y][x] ? 255 : 0;
                }
            }
            return buffer;
        }
    }

    /**
     * Unified export method for all formats
     */
    static async exportBitmap(bitmapData, format = 'u8g2', projectName = 'bitmap', options = {}) {
        const { width, height, pixels } = bitmapData;

        switch (format) {
            case 'u8g2':
                return this.generateHFile(bitmapData, projectName, 'u8g2');
            case 'adafruit':
                return this.generateHFile(bitmapData, projectName, 'adafruit');
            case 'playdate':
                return this.generateHFile(bitmapData, projectName, 'playdate');
            case 'gameboy':
                return this.generateHFile(bitmapData, projectName, 'gameboy');
            case 'svg':
                return this.generateSVG(bitmapData, projectName, options);
            case 'base64':
                return await this.generateBase64(bitmapData, options.imageFormat || 'png', options);
            case 'json':
                return this.generateJSON(bitmapData, projectName, options);
            case 'ascii':
                return this.generateASCII(bitmapData, projectName, options);
            case 'css':
                return await this.generateCSS(bitmapData, projectName, options);
            case 'raw':
                return this.generateRawBinary(bitmapData, options);
            case 'png':
            case 'webp':
                return await this.generateBase64(bitmapData, format, options);
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }

    /**
     * Download exported data as file
     */
    static downloadExport(data, filename, format) {
        const mimeTypes = {
            'svg': 'image/svg+xml',
            'json': 'application/json',
            'css': 'text/css',
            'ascii': 'text/plain',
            'u8g2': 'text/plain',
            'adafruit': 'text/plain',
            'playdate': 'text/plain',
            'gameboy': 'text/plain',
            'raw': 'application/octet-stream'
        };

        const fileExtensions = {
            'svg': '.svg',
            'json': '.json',
            'css': '.css',
            'ascii': '.txt',
            'u8g2': '.h',
            'adafruit': '.h',
            'playdate': '.h',
            'gameboy': '.h',
            'raw': '.bin'
        };

        let blob;
        const mimeType = mimeTypes[format] || 'text/plain';
        const extension = fileExtensions[format] || '.txt';

        if (format === 'raw') {
            blob = new Blob([data], { type: mimeType });
        } else if (format === 'base64' || format === 'png' || format === 'webp') {
            // For base64 data URLs, extract the base64 part and convert to blob
            if (typeof data === 'string' && data.startsWith('data:')) {
                const base64Data = data.split(',')[1];
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                blob = new Blob([bytes], { type: data.split(';')[0].split(':')[1] });
            } else {
                blob = new Blob([data], { type: mimeType });
            }
        } else {
            blob = new Blob([data], { type: mimeType });
        }

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename + extension;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    /**
     * Get file size estimate for export format
     */
    static getExportSizeEstimate(bitmapData, format) {
        const { width, height } = bitmapData;
        const pixelCount = width * height;

        switch (format) {
            case 'u8g2':
            case 'adafruit':
                return Math.ceil(pixelCount / 8) * 5; // Hex representation overhead
            case 'playdate':
                return Math.ceil(pixelCount / 8) * 5;
            case 'gameboy':
                return Math.ceil(width / 8) * height * 16 * 5; // 16 bytes per tile
            case 'svg':
                return width * height * 20; // Estimate for path data
            case 'json':
                return pixelCount * 2; // Array representation
            case 'ascii':
                return pixelCount * 2; // Character representation
            case 'raw':
                return Math.ceil(pixelCount / 8); // Packed bits
            case 'png':
            case 'webp':
                return pixelCount * 4; // Rough estimate for image data
            default:
                return pixelCount;
        }
    }

    // Legacy method for backward compatibility
    static pixelsToBytes(pixels, width, height) {
        return this.pixelsToBytesU8G2(pixels, width, height);
    }

    static copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            return navigator.clipboard.writeText(text);
        } else {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            return new Promise((resolve, reject) => {
                try {
                    document.execCommand('copy');
                    textArea.remove();
                    resolve();
                } catch (err) {
                    textArea.remove();
                    reject(err);
                }
            });
        }
    }

    static parseDimensions(code) {
        const widthMatch = code.match(/\/\/\s*Size:\s*(\d+)\s*x\s*(\d+)/);
        if (widthMatch) {
            return {
                width: parseInt(widthMatch[1]),
                height: parseInt(widthMatch[2])
            };
        }
        
        const drawXBMMatch = code.match(/drawXBM\([^,]+,\s*[^,]+,\s*(\d+),\s*(\d+)/);
        if (drawXBMMatch) {
            return {
                width: parseInt(drawXBMMatch[1]),
                height: parseInt(drawXBMMatch[2])
            };
        }
        
        return null;
    }

    static parseHFile(code) {
        try {
            const dimensions = this.parseDimensions(code);
            if (!dimensions) {
                throw new Error('Could not parse bitmap dimensions from code');
            }
            
            const { width, height } = dimensions;
            
            const arrayMatch = code.match(/{\s*((?:0x[0-9a-fA-F]{2}(?:,\s*)?)+)\s*}/);
            if (!arrayMatch) {
                throw new Error('Could not parse byte array from code');
            }
            
            const hexValues = arrayMatch[1].match(/0x[0-9a-fA-F]{2}/g);
            if (!hexValues) {
                throw new Error('No valid hex values found');
            }
            
            const bytes = hexValues.map(hex => parseInt(hex, 16));
            const pixels = this.bytesToPixels(bytes, width, height);
            
            return {
                width,
                height,
                pixels
            };
        } catch (error) {
            console.error('Error parsing H file:', error);
            throw error;
        }
    }

    static bytesToPixels(bytes, width, height) {
        const pixels = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            pixels[y] = new Array(width).fill(0);
            
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                const bytePos = y * bytesPerRow + byteIndex;
                if (bytePos < bytes.length) {
                    const byte = bytes[bytePos];
                    
                    for (let bit = 0; bit < 8; bit++) {
                        const x = byteIndex * 8 + bit;
                        if (x < width) {
                            pixels[y][x] = (byte & (1 << bit)) ? 1 : 0;
                        }
                    }
                }
            }
        }
        
        return pixels;
    }
}

// Backward compatibility alias
const U8G2Exporter = BitmapExporter;