class BitmapExporter {
    static generateHFile(bitmapData, projectName = 'my_bitmap', format = 'u8g2') {
        const { width, height, pixels } = bitmapData;
        
        let bytes, code;
        
        switch (format) {
            case 'adafruit':
                bytes = this.pixelsToBytesAdafruit(pixels, width, height);
                code = this.generateAdafruitCode(bytes, width, height, projectName);
                break;
            case 'playdate':
                return this.generatePlaydatePDI(pixels, width, height, projectName);
            case 'gameboy':
                return this.generateGameBoy2BPP(pixels, width, height, projectName);
            default: // u8g2
                bytes = this.pixelsToBytesU8G2(pixels, width, height);
                code = this.generateU8G2Code(bytes, width, height, projectName);
                break;
        }
        
        return code;
    }

    static generateU8G2Code(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.1 - U8G2 Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: XBM (LSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// u8g2.drawXBM(x, y, ${width}, ${height}, ${projectName});`;
        
        return code;
    }

    static generateAdafruitCode(bytes, width, height, projectName) {
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.1 - Adafruit Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: Adafruit GFX (MSB first, horizontal bytes)\n\n`;
        code += `const unsigned char ${projectName}[] PROGMEM = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `  ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Usage example:\n`;
        code += `// display.drawBitmap(x, y, ${projectName}, ${width}, ${height}, color);`;
        
        return code;
    }

    static pixelsToBytesU8G2(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // U8G2 uses LSB first (XBM format)
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << bit);
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    static pixelsToBytesAdafruit(pixels, width, height) {
        const bytes = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                let byte = 0;
                
                // Adafruit uses MSB first
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        const pixelValue = pixels[y][x];
                        if (pixelValue) {
                            byte |= (1 << (7 - bit)); // MSB first
                        }
                    }
                }
                
                bytes.push(byte);
            }
        }
        
        return bytes;
    }

    // Playdate PDI format implementation
    static generatePlaydatePDI(pixels, width, height, projectName) {
        // Create byte array for PDI format
        const stride = Math.ceil(width / 8);
        const bytes = [];
        
        // Convert pixels to Playdate format (0 = black, 1 = white)
        for (let y = 0; y < height; y++) {
            for (let byteIndex = 0; byteIndex < stride; byteIndex++) {
                let byte = 0;
                for (let bit = 0; bit < 8; bit++) {
                    const x = byteIndex * 8 + bit;
                    if (x < width) {
                        // In BitsDraw: 1 = black, 0 = white
                        // In Playdate: 0 = black, 1 = white
                        // So we need to invert
                        const pixelValue = pixels[y][x] ? 0 : 1;
                        if (pixelValue) {
                            byte |= (1 << (7 - bit)); // MSB first for Playdate
                        }
                    }
                }
                bytes.push(byte);
            }
        }
        
        const hexValues = bytes.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.1 - Playdate PDI Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Data size: ${bytes.length} bytes\n`;
        code += `// Format: Playdate PDI (0=black, 1=white, MSB first)\n`;
        code += `// Note: This is raw bitmap data. For actual PDI file, add header.\n\n`;
        code += `static const uint8_t ${projectName}_bitmap[] = {\n`;
        
        for (let i = 0; i < hexValues.length; i += 16) {
            const lineValues = hexValues.slice(i, i + 16);
            code += `    ${lineValues.join(', ')}`;
            if (i + 16 < hexValues.length) {
                code += ',';
            }
            code += '\n';
        }
        
        code += `};\n\n`;
        code += `// Playdate C API usage:\n`;
        code += `// LCDBitmap* bitmap = pd->graphics->newBitmap(${width}, ${height}, kColorWhite);\n`;
        code += `// pd->graphics->getBitmapData(bitmap, NULL, NULL, &rowbytes, NULL, &data);\n`;
        code += `// memcpy(data, ${projectName}_bitmap, sizeof(${projectName}_bitmap));\n`;
        
        return code;
    }
    
    // Game Boy 2BPP format implementation
    static generateGameBoy2BPP(pixels, width, height, projectName) {
        // Game Boy uses 8x8 tiles
        const tilesX = Math.ceil(width / 8);
        const tilesY = Math.ceil(height / 8);
        const tiles = [];
        
        // Process each 8x8 tile
        for (let tileY = 0; tileY < tilesY; tileY++) {
            for (let tileX = 0; tileX < tilesX; tileX++) {
                const tile = [];
                
                // Each tile is 16 bytes (8 rows Ã— 2 bytes per row)
                for (let row = 0; row < 8; row++) {
                    let lowByte = 0;
                    let highByte = 0;
                    
                    for (let col = 0; col < 8; col++) {
                        const x = tileX * 8 + col;
                        const y = tileY * 8 + row;
                        
                        // Get pixel value (default to 0 if outside bounds)
                        let pixelValue = 0;
                        if (x < width && y < height) {
                            // Convert 1-bit to 2-bit
                            // BitsDraw: 1 = black, 0 = white
                            // Game Boy: 0 = white, 3 = black
                            pixelValue = pixels[y][x] ? 3 : 0;
                        }
                        
                        // Extract low and high bits
                        const lowBit = pixelValue & 1;
                        const highBit = (pixelValue >> 1) & 1;
                        
                        // Pack bits (MSB first)
                        lowByte |= (lowBit << (7 - col));
                        highByte |= (highBit << (7 - col));
                    }
                    
                    // Game Boy format: low byte first, then high byte
                    tile.push(lowByte);
                    tile.push(highByte);
                }
                
                tiles.push(...tile);
            }
        }
        
        const hexValues = tiles.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        
        let code = `// Generated by BitsDraw v1.0.1 - Game Boy 2BPP Format\n`;
        code += `// Size: ${width} x ${height} pixels\n`;
        code += `// Tiles: ${tilesX} x ${tilesY} (${tilesX * tilesY} tiles)\n`;
        code += `// Data size: ${tiles.length} bytes\n`;
        code += `// Format: Game Boy 2BPP (16 bytes per 8x8 tile)\n\n`;
        code += `const unsigned char ${projectName}_tiles[] = {\n`;
        
        // Format output with comments for each tile
        let tileIndex = 0;
        for (let i = 0; i < hexValues.length; i += 16) {
            code += `    // Tile ${tileIndex}\n`;
            const tileBytes = hexValues.slice(i, i + 16);
            
            // Output 8 rows (2 bytes each)
            for (let row = 0; row < 8; row++) {
                const rowBytes = tileBytes.slice(row * 2, row * 2 + 2);
                code += `    ${rowBytes.join(', ')}`;
                if (row < 7 || i + 16 < hexValues.length) {
                    code += ',';
                }
                code += `  // Row ${row}\n`;
            }
            
            if (i + 16 < hexValues.length) {
                code += '\n';
            }
            tileIndex++;
        }
        
        code += `};\n\n`;
        code += `// GBDK usage example:\n`;
        code += `// set_bkg_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        code += `// For sprites: set_sprite_data(0, ${tilesX * tilesY}, ${projectName}_tiles);\n`;
        
        return code;
    }

    // Legacy method for backward compatibility
    static pixelsToBytes(pixels, width, height) {
        return this.pixelsToBytesU8G2(pixels, width, height);
    }

    static copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            return navigator.clipboard.writeText(text);
        } else {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            return new Promise((resolve, reject) => {
                try {
                    document.execCommand('copy');
                    textArea.remove();
                    resolve();
                } catch (err) {
                    textArea.remove();
                    reject(err);
                }
            });
        }
    }

    static parseDimensions(code) {
        const widthMatch = code.match(/\/\/\s*Size:\s*(\d+)\s*x\s*(\d+)/);
        if (widthMatch) {
            return {
                width: parseInt(widthMatch[1]),
                height: parseInt(widthMatch[2])
            };
        }
        
        const drawXBMMatch = code.match(/drawXBM\([^,]+,\s*[^,]+,\s*(\d+),\s*(\d+)/);
        if (drawXBMMatch) {
            return {
                width: parseInt(drawXBMMatch[1]),
                height: parseInt(drawXBMMatch[2])
            };
        }
        
        return null;
    }

    static parseHFile(code) {
        try {
            const dimensions = this.parseDimensions(code);
            if (!dimensions) {
                throw new Error('Could not parse bitmap dimensions from code');
            }
            
            const { width, height } = dimensions;
            
            const arrayMatch = code.match(/{\s*((?:0x[0-9a-fA-F]{2}(?:,\s*)?)+)\s*}/);
            if (!arrayMatch) {
                throw new Error('Could not parse byte array from code');
            }
            
            const hexValues = arrayMatch[1].match(/0x[0-9a-fA-F]{2}/g);
            if (!hexValues) {
                throw new Error('No valid hex values found');
            }
            
            const bytes = hexValues.map(hex => parseInt(hex, 16));
            const pixels = this.bytesToPixels(bytes, width, height);
            
            return {
                width,
                height,
                pixels
            };
        } catch (error) {
            console.error('Error parsing H file:', error);
            throw error;
        }
    }

    static bytesToPixels(bytes, width, height) {
        const pixels = [];
        const bytesPerRow = Math.ceil(width / 8);
        
        for (let y = 0; y < height; y++) {
            pixels[y] = new Array(width).fill(0);
            
            for (let byteIndex = 0; byteIndex < bytesPerRow; byteIndex++) {
                const bytePos = y * bytesPerRow + byteIndex;
                if (bytePos < bytes.length) {
                    const byte = bytes[bytePos];
                    
                    for (let bit = 0; bit < 8; bit++) {
                        const x = byteIndex * 8 + bit;
                        if (x < width) {
                            pixels[y][x] = (byte & (1 << bit)) ? 1 : 0;
                        }
                    }
                }
            }
        }
        
        return pixels;
    }
}

// Backward compatibility alias
const U8G2Exporter = BitmapExporter;